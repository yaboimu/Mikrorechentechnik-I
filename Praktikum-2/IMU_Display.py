from machine import Pin, SPI, I2C # SPI (short-distance-comm.) is for transferring data to the display and I2C is for the communication
import utime                      # for the delays we need
from MPU6050 import MPU6050       # to interract with the sensor
import framebuf                   # to create a framebuffer (RAM that contains bitmaps which will drive some display) that is needed in order to see display 
# Setting I2C to communicate with the sensor MPU6050
import st7789py as st7789
import vga1_16x32 as font1  # Import a compatible font
import vga1_8x16 as font2
i2c = I2C(0, sda= machine.Pin(0), scl= machine.Pin(1), freq = 400) # i2c clk is on pin 21 and i2c data is on pin 20 #i2c peripheral is selceted as 0*
sensor = MPU6050(i2c)             # object created for sensor which is interacted with the I2C
# Setting SPI to communicate with the Waveshare Pico-LCD-1.14 display
#spi = SPI(1, baudrate=32000000, polarity=0, phase=0, sck=machine.Pin(10), mosi=machine.Pin(11)) # spi peripheral 1 at 32000 kHz for sending the data to lcd
spi = SPI(1, baudrate = 4000000, sck=machine.Pin(10), mosi=machine.Pin(11), miso=None)
# Here sck is serial clk generated by master, mosi is master-out-slave-in so data is transmitted by master to slave
# Data pin for communication is selected 11 and clk pin is selected 10

lcd_dc = Pin(8, machine.Pin.OUT)  # data/command pin for the display
lcd_cs = Pin(9, machine.Pin.OUT)  # chip select pin for the display
lcd_rst = Pin(12, machine.Pin.OUT) # reset pin for the display
# three of these will ensure a proper communication with the display overspi interface
lcd_bl = Pin(13, Pin.OUT)  # Backlight pin (optional)
lcd_bl.value(1)  # Turn on the backlight
# from the link https://www.waveshare.com/wiki/Pico-LCD-1.14#LVGL_Initialization display setup:
# buttons:
button1 = machine.Pin(15, machine.Pin.IN, machine.Pin.PULL_UP) # for changing display modes
button2 = machine.Pin(17, machine.Pin.IN, machine.Pin.PULL_UP) # for showing all the data
# Initialize the ST7789 Display
display = st7789.ST7789(spi, 135, 240, reset=lcd_rst, cs=lcd_cs, dc=lcd_dc, backlight=lcd_bl)

# Fill the display with black


class pico_LCD:
    def __init__(self, spi, dc, cs, rst):
        self.spi = spi
        self.dc = dc
        self.cs = cs
        self.rst = rst
        self.fbuf = framebuf.FrameBuffer(bytearray(width * height * 2), width, height, framebuf.RGB565)
        # since framebuffer needs 2 bytes for every rgb565 (16-bit rgb) pixel we multiply with 2
        self.init_display()
        
    # Function for initialize/restart the Waveshare Pico-LCD-1.14 display
    def init_display(self):
        self.rst.value(0) # this resets the all existing data
        utime.sleep(0.1)
        self.rst.value(1) # deactivates reset so now we initialized the process.
        


# Function for sending the data in framebuffer we set to the physical LCD
    def show(self):
        self.cs.value(0) # enables communication with the display
        self.dc.value(0) # dc pin is in command mode now 
        # Send framebuffer to display
        self.spi.write(self.fbuf) # frambuffer data is sent to display
        self.cs.value(1) # stop communication
        
# for filling the screen, except for the text, with a color. (this can be determined in rgb565 colors)
    def fill(self, color):
        self.fbuf.fill(color)
        
# for the text that will show the coordinates in desired color of text (also this is adjustable too)  
    def text(self, text, x, y, color):
        self.fbuf.text(text, x, y, color)
        
# Finally, call the class LCD with its parameters and asign it to an object which we give lcd.



# now to read the data from the sensor mpu6050:
def read_sensor_data():
    accel = sensor.read_accel_data() # sensor defined on row 8
    gyro = sensor.read_gyro_data()
    return accel, gyro

# then the data that we obtained above will be displayed:
def display_sensor_data(accel, gyro, mode):
    """Displays sensor data on the ST7789 screen."""
      # Clear the screen

    if mode == 0:  # Only Acceleration Data
        display.text(font1, f"Accel X: {accel['x']:.2f}", 10, 10, st7789.WHITE)
        display.text(font1, f"Accel Y: {accel['y']:.2f}", 10, 50, st7789.WHITE)
        display.text(font1, f"Accel Z: {accel['z']:.2f}", 10, 90, st7789.WHITE)
    elif mode == 1:  # Only Gyroscope Data
        display.text(font1, f"Gyro X: {gyro['x']:.2f}", 10, 10, st7789.WHITE)
        display.text(font1, f"Gyro Y: {gyro['y']:.2f}", 10, 50, st7789.WHITE)
        display.text(font1, f"Gyro Z: {gyro['z']:.2f}", 10, 90, st7789.WHITE)
    elif mode == 2:  # Both Acceleration and Gyroscope Data
        display.text(font2, f"Accel X: {accel['x']:.2f}", 1, 10, st7789.WHITE)
        display.text(font2, f"Accel Y: {accel['y']:.2f}", 1, 50, st7789.WHITE)
        display.text(font2, f"Accel Z: {accel['z']:.2f}", 1, 90, st7789.WHITE)
        display.text(font2, f"Gyro X: {gyro['x']:.2f}", 119, 10, st7789.WHITE)
        display.text(font2, f"Gyro Y: {gyro['y']:.2f}", 119, 50, st7789.WHITE)
        display.text(font2, f"Gyro Z: {gyro['z']:.2f}", 119, 90, st7789.WHITE)

# now main function for this code: 
mode = 0 # to start at the mode 0

while True:
    accel_data, gyro_data = read_sensor_data() # we get the data
    display_sensor_data(accel_data, gyro_data, mode)  # we put the data to screen with respect to the mode seleceted

    if not button1.value():
        mode = (mode + 1) % 2 # since button1 is for changing between accel and gyro
        utime.sleep(0.1)
        display.fill(st7789.BLACK)

    if not button2.value():       # since button2 is for showing all the data both accel and gyro
        mode = 2
        utime.sleep(0.1)
        display.fill(st7789.BLACK)

  
